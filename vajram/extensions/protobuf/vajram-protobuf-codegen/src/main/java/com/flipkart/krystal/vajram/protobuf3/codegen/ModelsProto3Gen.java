package com.flipkart.krystal.vajram.protobuf3.codegen;

import static com.flipkart.krystal.datatypes.JavaTypes.BYTE;
import static com.flipkart.krystal.vajram.codegen.common.models.Utils.getIfNoValue;
import static com.flipkart.krystal.vajram.protobuf3.codegen.Constants.MODELS_PROTO_MSG_SUFFIX;
import static com.flipkart.krystal.vajram.protobuf3.codegen.ModelsProto3SchemaGen.validateModelType;
import static com.flipkart.krystal.vajram.protobuf3.codegen.ProtoGenUtils.isProtoTypeMap;
import static com.flipkart.krystal.vajram.protobuf3.codegen.ProtoGenUtils.isProtoTypeRepeated;
import static com.squareup.javapoet.MethodSpec.methodBuilder;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

import com.flipkart.krystal.data.IfAbsent;
import com.flipkart.krystal.data.IfAbsent.IfAbsentThen;
import com.flipkart.krystal.datatypes.DataType;
import com.flipkart.krystal.model.ModelRoot;
import com.flipkart.krystal.serial.SerializableModel;
import com.flipkart.krystal.vajram.codegen.common.models.CodegenPhase;
import com.flipkart.krystal.vajram.codegen.common.models.DeclaredTypeVisitor;
import com.flipkart.krystal.vajram.codegen.common.models.Utils;
import com.flipkart.krystal.vajram.codegen.common.spi.CodeGenerator;
import com.flipkart.krystal.vajram.codegen.common.spi.ModelsCodeGenContext;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.MethodSpec.Builder;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import java.util.ArrayList;
import java.util.List;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import lombok.extern.slf4j.Slf4j;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * This code generator generates implementations in the model root hierarchy. More specifically, it
 * generates a final class name "[ModelName]_ImmutProto" which extends the "[ModelName]_Immut"
 * interface and the {@link SerializableModel} interface. This class wraps the proto java model
 * generated by protoc, whose name is "[ModelName]_Proto". All the getters in the class delegate to
 * the proto model. It also contains a lazily initialized byte array field named
 * "_serializedPayload". This is initialized in a constructor which accepts a byte array. This also
 * generates an inner class inside the ImmutProto class which extends the
 * "[ModelName]_Immut.Builder" interface and wraps a "[ModelName]_Proto.Builder" instance and all
 * setter and getter calls are delegated to this.
 */
@Slf4j
public class ModelsProto3Gen implements CodeGenerator {

  private final ModelsCodeGenContext codeGenContext;
  private final Utils util;

  public ModelsProto3Gen(ModelsCodeGenContext codeGenContext) {
    this.codeGenContext = codeGenContext;
    this.util = codeGenContext.util();
  }

  @Override
  public void generate() {
    if (!isApplicable()) {
      return;
    }
    validate();
    generateProtoImplementation();
  }

  private boolean isApplicable() {
    if (!CodegenPhase.FINAL.equals(codeGenContext.codegenPhase())) {
      util.note("Skipping protobuf codegen since current phase is not FINAL");
      return false;
    }

    TypeElement modelRootType = codeGenContext.modelRootType();
    // Check if the model root has the ModelRoot annotation
    ModelRoot modelRootAnnotation = modelRootType.getAnnotation(ModelRoot.class);
    if (modelRootAnnotation == null) {
      util.note(
          "Skipping class '%s' since it doesn't have @ModelRoot annotation"
              .formatted(modelRootType.getQualifiedName()));
      return false;
    }

    return true;
  }

  private void validate() {
    TypeElement modelRootType = codeGenContext.modelRootType();
    validateModelType(modelRootType, util);
  }

  private void generateProtoImplementation() {
    TypeElement modelRootType = codeGenContext.modelRootType();
    ModelRoot modelRoot = modelRootType.getAnnotation(ModelRoot.class);

    String modelRootName = modelRootType.getSimpleName().toString();
    String packageName =
        util.processingEnv().getElementUtils().getPackageOf(modelRootType).toString();
    String protoClassName = modelRootName + modelRoot.suffixSeperator() + "ImmutProto";

    // Generate the implementation class using JavaPoet
    TypeSpec typeSpec = generateImplementationTypeSpec(modelRootType, packageName, protoClassName);

    // Create JavaFile and write to source file
    JavaFile javaFile = JavaFile.builder(packageName, typeSpec).build();

    util.generateSourceFile(packageName + "." + protoClassName, javaFile.toString(), modelRootType);

    log.info("Generated protobuf implementation class: {}", protoClassName);
  }

  private TypeSpec generateImplementationTypeSpec(
      TypeElement modelRootType, String packageName, String protoClassName) {
    ModelRoot modelRoot = modelRootType.getAnnotation(ModelRoot.class);
    ClassName immutableProtoType = ClassName.get(packageName, protoClassName);
    String modelRootName = modelRootType.getSimpleName().toString();
    String immutInterfaceName = modelRootName + modelRoot.suffixSeperator() + "Immut";
    String protoMsgClassName = modelRootName + MODELS_PROTO_MSG_SUFFIX;

    // Extract model methods
    List<ExecutableElement> modelMethods = util.extractAndValidateModelMethods(modelRootType);

    // Create class annotations
    AnnotationSpec suppressWarningsAnnotation =
        AnnotationSpec.builder(SuppressWarnings.class)
            .addMember("value", "$L", "{\"unchecked\", \"ClassReferencesSubclass\"}")
            .build();

    // Create class interfaces
    ClassName immutInterfaceClassName = ClassName.get(packageName, immutInterfaceName);
    ClassName serializableClassName = ClassName.get(SerializableModel.class);

    // Create field types
    TypeName byteArrayType = ArrayTypeName.of(TypeName.BYTE);
    ClassName protoMsgType = ClassName.get(packageName, protoMsgClassName);
    TypeName nullableProtoMsgType =
        protoMsgType.annotated(AnnotationSpec.builder(Nullable.class).build());

    // Create class builder
    TypeSpec.Builder classBuilder =
        TypeSpec.classBuilder(protoClassName)
            .addModifiers(PUBLIC)
            .addAnnotation(suppressWarningsAnnotation)
            .addSuperinterface(immutInterfaceClassName)
            .addSuperinterface(serializableClassName);

    util.addGeneratedAnnotations(classBuilder);

    // Add fields
    classBuilder.addField(FieldSpec.builder(byteArrayType, "_serializedPayload", PRIVATE).build());
    classBuilder.addField(FieldSpec.builder(nullableProtoMsgType, "_proto", PRIVATE).build());

    // Add constructor for serialized payload
    classBuilder.addMethod(
        MethodSpec.constructorBuilder()
            .addModifiers(PUBLIC)
            .addParameter(byteArrayType, "_serializedPayload")
            .addStatement("this._serializedPayload = _serializedPayload")
            .addStatement("this._proto = null")
            .build());

    // Add constructor for proto message
    classBuilder.addMethod(
        MethodSpec.constructorBuilder()
            .addModifiers(PUBLIC)
            .addParameter(protoMsgType, "_proto")
            .addStatement("this._proto = _proto")
            .addStatement("this._serializedPayload = null")
            .build());

    // Add _serialize method from Serializable interface with lazy initialization
    classBuilder.addMethod(
        MethodSpec.methodBuilder("_serialize")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(byteArrayType)
            .beginControlFlow("if (_serializedPayload == null)")
            .addStatement("this._serializedPayload = _proto.toByteArray()")
            .endControlFlow()
            .addStatement("return _serializedPayload")
            .build());

    // Add _build method from ImmutableModel interface
    classBuilder.addMethod(
        MethodSpec.methodBuilder("_build")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(immutInterfaceClassName)
            .addStatement("return this")
            .build());

    // Add _asBuilder method from ImmutableModel interface
    classBuilder.addMethod(
        MethodSpec.methodBuilder("_asBuilder")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(ClassName.get("", "Builder"))
            .addStatement("return new Builder(_proto().toBuilder())")
            .build());

    // Add _newCopy method from ImmutableModel interface
    classBuilder.addMethod(
        MethodSpec.methodBuilder("_newCopy")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(immutInterfaceClassName)
            .addStatement("return new $L(_serializedPayload)", protoClassName)
            .build());

    // Add method to lazily deserialize the proto message
    MethodSpec.Builder getProtoMsgBuilder =
        MethodSpec.methodBuilder("_proto")
            .addModifiers(PUBLIC)
            .returns(protoMsgType)
            .beginControlFlow("if (_proto == null && _serializedPayload != null)")
            .beginControlFlow("try")
            .addStatement("_proto = $T.parseFrom(_serializedPayload)", protoMsgType)
            .nextControlFlow("catch (Exception e)")
            .addStatement("throw new RuntimeException(\"Failed to deserialize proto message\", e)")
            .endControlFlow()
            .endControlFlow()
            .beginControlFlow("if (_proto == null)")
            .addStatement(
                "throw new IllegalStateException(\"Both _proto and _serializedPayload are null\")")
            .endControlFlow()
            .addStatement("return _proto");

    classBuilder.addMethod(getProtoMsgBuilder.build());

    // Add getters for all model methods
    for (ExecutableElement method : modelMethods) {
      String methodName = method.getSimpleName().toString();

      // Get the return type
      TypeMirror returnType = method.getReturnType();
      DataType<?> dataType = new DeclaredTypeVisitor<>(util, method).visit(returnType);
      TypeName typeName = TypeName.get(returnType);

      MethodSpec.Builder getterBuilder =
          MethodSpec.methodBuilder(methodName).addAnnotation(Override.class).addModifiers(PUBLIC);

      // Only add @Nullable annotation if the field needs presence check, is not FAIL,
      // and the return type is not Optional
      if (needsPresenceCheckInModels(method)
          && !isMandatoryField(method)
          && !util.isOptional(returnType)) {
        getterBuilder.returns(typeName.annotated(AnnotationSpec.builder(Nullable.class).build()));
      } else {
        getterBuilder.returns(typeName);
      }

      addGetterCode(getterBuilder, method, dataType, methodName);

      classBuilder.addMethod(getterBuilder.build());
    }

    // Add equals method that delegates to the proto object
    MethodSpec equalsMethod =
        MethodSpec.methodBuilder("equals")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(boolean.class)
            .addParameter(Object.class, "obj")
            .addCode(
                """
                if (this == obj) {
                  return true;
                }
                if (obj == null || getClass() != obj.getClass()) {
                  return false;
                }
                $L other = ($L) obj;
                return _proto().equals(other._proto());
                """,
                protoClassName,
                protoClassName)
            .build();
    classBuilder.addMethod(equalsMethod);

    // Add hashCode method that delegates to the proto object
    MethodSpec hashCodeMethod =
        MethodSpec.methodBuilder("hashCode")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(int.class)
            .addStatement("return _proto().hashCode()")
            .build();
    classBuilder.addMethod(hashCodeMethod);

    // Add Builder inner class
    TypeSpec builderTypeSpec =
        generateBuilderTypeSpec(
            packageName, protoClassName, protoMsgClassName, immutInterfaceName, modelMethods);
    classBuilder.addType(builderTypeSpec);
    classBuilder.addMethod(
        methodBuilder("_builder")
            .addModifiers(PUBLIC, STATIC)
            .returns(immutableProtoType.nestedClass("Builder"))
            .addStatement("return new $T()", immutableProtoType.nestedClass("Builder"))
            .build());
    return classBuilder.build();
  }

  private void addGetterCode(
      Builder getterBuilder, ExecutableElement method, DataType<?> dataType, String methodName) {

    if (isProtoTypeRepeated(dataType)) {
      // For repeated fields, use getXList() method
      getterBuilder.addStatement(
          "return _proto().get$LList()", ProtoGenUtils.capitalize(methodName));
      return;
    }

    if (isProtoTypeMap(dataType)) {
      // For map fields, use getXMap() method
      getterBuilder.addStatement(
          "return _proto().get$LMap()", ProtoGenUtils.capitalize(methodName));
      return;
    }
    boolean isOptionalReturnType = util.isOptional(method.getReturnType());

    // Return null for fields which can be inspected for presence/absence of value
    if (needsPresenceCheckInModels(method)) {
      CodeBlock protoPresenceCheck =
          CodeBlock.of(
              """
              if (!_proto().has$L()){
              """,
              ProtoGenUtils.capitalize(methodName));

      // Add validation for mandatory fields
      if (isMandatoryField(method)) {
        getterBuilder
            .addCode(protoPresenceCheck)
            .addCode(
                """
                throw new IllegalStateException("Field $L is mandatory but has no value");
              }
              """,
                methodName);
      } else if (isOptionalReturnType) {
        getterBuilder
            .addCode(protoPresenceCheck)
            .addCode(
                """
                return Optional.empty();
              }
              """);
      } else {
        getterBuilder
            .addCode(protoPresenceCheck)
            .addCode(
                """
                return null;
              }
              """);
      }
    }

    // Get the value from the proto message
    if (isOptionalReturnType) {
      getterBuilder.addStatement(
          "return Optional.of(_proto().get$L())", ProtoGenUtils.capitalize(methodName));
    } else {
      getterBuilder.addStatement("return _proto().get$L()", ProtoGenUtils.capitalize(methodName));
    }
  }

  private TypeSpec generateBuilderTypeSpec(
      String packageName,
      String protoClassName,
      String protoMsgClassName,
      String immutInterfaceName,
      List<ExecutableElement> modelMethods) {

    ClassName immutableProtoType = ClassName.get(packageName, protoClassName);

    // Create class interfaces
    ClassName builderInterfaceClassName =
        ClassName.get(packageName, immutInterfaceName).nestedClass("Builder");

    ClassName protoBuilderClassName =
        ClassName.get(packageName, protoMsgClassName).nestedClass("Builder");
    ClassName protoMsgClassNameObj = ClassName.get(packageName, protoMsgClassName);

    // Create Builder class
    TypeSpec.Builder builderClassBuilder =
        TypeSpec.classBuilder("Builder")
            .addModifiers(PUBLIC, STATIC)
            .addSuperinterface(builderInterfaceClassName);

    util.addGeneratedAnnotations(builderClassBuilder);

    // Add Builder field
    builderClassBuilder.addField(
        FieldSpec.builder(protoBuilderClassName, "_proto", PRIVATE, FINAL).build());

    // Add Builder constructor with _proto parameter
    builderClassBuilder.addMethod(
        MethodSpec.constructorBuilder()
            .addParameter(protoBuilderClassName, "_proto")
            .addStatement("this._proto = _proto")
            .build());

    // Add Builder default constructor
    builderClassBuilder.addMethod(
        MethodSpec.constructorBuilder()
            .addModifiers(PUBLIC)
            .addStatement("this._proto = $T.newBuilder()", protoMsgClassNameObj)
            .build());

    // Add _build method
    builderClassBuilder.addMethod(
        MethodSpec.methodBuilder("_build")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(immutableProtoType)
            .addStatement("return new $L(_proto.build())", protoClassName)
            .build());

    // Add _asBuilder method
    builderClassBuilder.addMethod(
        MethodSpec.methodBuilder("_asBuilder")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(ClassName.get("", "Builder"))
            .addStatement("return this")
            .build());

    // Add _newCopy method
    builderClassBuilder.addMethod(
        MethodSpec.methodBuilder("_newCopy")
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .returns(ClassName.get("", "Builder"))
            .addStatement("return new Builder(_proto.clone())")
            .build());

    // Add getters and setters for all model methods
    for (ExecutableElement method : modelMethods) {
      String methodName = method.getSimpleName().toString();
      TypeMirror returnType = method.getReturnType();
      DataType<?> dataType = new DeclaredTypeVisitor<>(util, method).visit(returnType);

      // Check if the return type is Optional
      boolean isOptionalReturnType = util.isOptional(returnType);
      TypeName typeName;

      if (isOptionalReturnType) {
        // Use the inner type for the parameter if the return type is Optional
        TypeMirror innerType = util.getOptionalInnerType(returnType);
        typeName = TypeName.get(innerType);
      } else {
        typeName = TypeName.get(returnType);
      }

      if (typeName.isPrimitive()) {
        typeName = typeName.box();
      }

      // Add setter method
      MethodSpec.Builder setterBuilder =
          MethodSpec.methodBuilder(methodName)
              .addAnnotation(Override.class)
              .addModifiers(PUBLIC)
              .returns(ClassName.get("", "Builder"));

      // Add parameter
      ParameterSpec.Builder paramBuilder = ParameterSpec.builder(typeName, methodName);
      paramBuilder.addAnnotation(Nullable.class);

      // Check if the field is a repeated field (List) or a map field
      if (isProtoTypeRepeated(dataType)) {
        // For repeated fields, use clear and addAll pattern
        setterBuilder.addCode(
            """
                  _proto.clear$L();
                  if ($L == null){
                    return this;
                  }
                  _proto.addAll$L($L);
                """,
            ProtoGenUtils.capitalize(methodName),
            methodName,
            ProtoGenUtils.capitalize(methodName),
            methodName);
      } else if (isProtoTypeMap(dataType)) {
        // For map fields, use clear and putAll pattern
        setterBuilder.addCode(
            """
                  _proto.clear$L();
                  if ($L == null){
                    return this;
                  }
                  _proto.putAll$L($L);
                """,
            ProtoGenUtils.capitalize(methodName),
            methodName,
            ProtoGenUtils.capitalize(methodName),
            methodName);
      } else {
        // For regular fields
        setterBuilder.addCode(
            """
                  if ($L == null){
                    _proto.clear$L();
                    return this;
                  }
                """,
            methodName,
            ProtoGenUtils.capitalize(methodName));

        setterBuilder.addStatement(
            dataType.equals(BYTE)
                ? "_proto.set$L(com.google.protobuf.ByteString.copyFrom(new byte[]{$L}))"
                : "_proto.set$L($L)",
            ProtoGenUtils.capitalize(methodName),
            methodName);
      }

      setterBuilder.addStatement("return this");

      builderClassBuilder.addMethod(setterBuilder.addParameter(paramBuilder.build()).build());
    }

    // Add method to access the proto builder
    return builderClassBuilder
        .addMethod(
            MethodSpec.methodBuilder("_proto")
                .addModifiers(PUBLIC)
                .returns(protoBuilderClassName)
                .addStatement("return _proto")
                .build())
        .build();
  }

  /**
   * Checks if a field needs presence check in the models. Fields with @IfNoValue(then=FAIL)
   * or @IfNoValue(then=MAY_FAIL_CONDITIONALLY) need presence check.
   */
  private static boolean needsPresenceCheckInModels(ExecutableElement method) {
    IfAbsent ifAbsent = getIfNoValue(method);

    // For FAIL and MAY_FAIL_CONDITIONALLY, we need presence check
    return ifAbsent.value() == IfAbsentThen.FAIL
        || ifAbsent.value() == IfAbsentThen.MAY_FAIL_CONDITIONALLY;
  }

  /**
   * Checks if a field should be treated as mandatory. Fields with @IfNoValue(then=FAIL) are treated
   * as mandatory.
   */
  private static boolean isMandatoryField(ExecutableElement method) {
    return getIfNoValue(method).value() == IfAbsentThen.FAIL;
  }
}
